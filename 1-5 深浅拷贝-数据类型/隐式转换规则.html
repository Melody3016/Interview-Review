<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    /*
      总结js中类型比较规则（隐式类型转换）
      js是一门弱类型语言，与其他强类型语言不通，在比较两个变量是否相等时，有两种比较操作符，严格相等运算符(===)和非严格相等运算符(==)。
      其中在使用非严格相等运算符(==)时，会出现一些预料之外的问题（隐式类型转换），以下是使用(==)比较时的一些规则：
      
      ## 1. 两边数据类型一致，进行全等比较
      ### 基本数据类型
      对于数据类型一致的基本数据类型，直接比较值是否相等。
      ```js
      1 == 1 // true
      'a' == 'b' // false
      ```
      ### 引用数据类型
      js引用数据类型相互比较时，其实只是比较内存地址值。要比较两个地址值不一样的引用类型数据，需要进行递归比较属性。（使用JSON序列化对比会有缺陷，无法序列化特殊属性如函数、Symbol、undefined等，特殊对象，循环引用等等）
      ```js
      [1] == [1] // false
      {name: 'zs'} == {name: 'zs'} // false
      const obj = {age:18}
      obj2 = obj
      obj == obj2 // true
      ```
      ## 2. 基本数据类型和引用类型比较，会先将引用类型转为基础类型
      引用类型转基本类型会依次调用[Symbol.toPrimitive]()，valueOf(), toString()方法去尝试转为基本类型，如上述方法都无法转换，则会报错

      ```js
      [1] == 1 // true
      // [1].valueOf() ==> [1]
      // [1].toString() ==> '1'
      ```

      ## 3. 基础数据类型之间比较
      字符串、数字，布尔值之间比较都会转换为数值

      ```js
      '12' == 12 // true
      '0' == false // true  Number(false) ==> 0
      ```

      ## 4. NaN与任何值比较都是false
      ## 5. undefined == null true

    */
  </script>

  <script>
    // 测试题
    
  </script>
</body>
</html>